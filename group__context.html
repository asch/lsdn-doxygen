<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LSDN: Context</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">LSDN
   </div>
   <div id="projectbrief">Linux Software Defined Networking</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Context</div>  </div>
</div><!--header-->
<div class="contents">

<p>Context, commits and high level network model management.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlsdn__context.html">lsdn_context</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">LSDN Context.  <a href="structlsdn__context.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga1b298b230140959c9d9a0e2d8c699e03"><td class="memItemLeft" align="right" valign="top"><a id="ga1b298b230140959c9d9a0e2d8c699e03"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__context.html#ga1b298b230140959c9d9a0e2d8c699e03">lsdn_nomem_cb</a>) (void *user)</td></tr>
<tr class="memdesc:ga1b298b230140959c9d9a0e2d8c699e03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signature for out-of-memory callback. <br /></td></tr>
<tr class="separator:ga1b298b230140959c9d9a0e2d8c699e03"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga7774773562a2fb2d2954f89a0b4cde8d"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structlsdn__context.html">lsdn_context</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__context.html#ga7774773562a2fb2d2954f89a0b4cde8d">lsdn_context_new</a> (const char *name)</td></tr>
<tr class="memdesc:ga7774773562a2fb2d2954f89a0b4cde8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new LSDN context.  <a href="#ga7774773562a2fb2d2954f89a0b4cde8d">More...</a><br /></td></tr>
<tr class="separator:ga7774773562a2fb2d2954f89a0b4cde8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6705027791e7b1fe533523e4458020ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__context.html#ga6705027791e7b1fe533523e4458020ee">lsdn_context_set_nomem_callback</a> (struct <a class="el" href="structlsdn__context.html">lsdn_context</a> *ctx, <a class="el" href="group__context.html#ga1b298b230140959c9d9a0e2d8c699e03">lsdn_nomem_cb</a> cb, void *user)</td></tr>
<tr class="memdesc:ga6705027791e7b1fe533523e4458020ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure out-of-memory callback.  <a href="#ga6705027791e7b1fe533523e4458020ee">More...</a><br /></td></tr>
<tr class="separator:ga6705027791e7b1fe533523e4458020ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa09dd71d3d8e6f6366c6107a6f24b67a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__context.html#gaa09dd71d3d8e6f6366c6107a6f24b67a">lsdn_context_abort_on_nomem</a> (struct <a class="el" href="structlsdn__context.html">lsdn_context</a> *ctx)</td></tr>
<tr class="memdesc:gaa09dd71d3d8e6f6366c6107a6f24b67a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure the context to abort on out-of-memory.  <a href="#gaa09dd71d3d8e6f6366c6107a6f24b67a">More...</a><br /></td></tr>
<tr class="separator:gaa09dd71d3d8e6f6366c6107a6f24b67a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5de5df0dc62be87ac5fcfb7479243e29"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__context.html#ga5de5df0dc62be87ac5fcfb7479243e29">lsdn_context_free</a> (struct <a class="el" href="structlsdn__context.html">lsdn_context</a> *ctx)</td></tr>
<tr class="memdesc:ga5de5df0dc62be87ac5fcfb7479243e29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free a LSDN context.  <a href="#ga5de5df0dc62be87ac5fcfb7479243e29">More...</a><br /></td></tr>
<tr class="separator:ga5de5df0dc62be87ac5fcfb7479243e29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaccf292c6b1c6a47b5ca5c77f7dd21f03"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__context.html#gaccf292c6b1c6a47b5ca5c77f7dd21f03">lsdn_context_cleanup</a> (struct <a class="el" href="structlsdn__context.html">lsdn_context</a> *ctx, <a class="el" href="include_2errors_8h.html#afd569abca2f30df45351f01302e98a37">lsdn_problem_cb</a> cb, void *user)</td></tr>
<tr class="memdesc:gaccf292c6b1c6a47b5ca5c77f7dd21f03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear a LSDN context.  <a href="#gaccf292c6b1c6a47b5ca5c77f7dd21f03">More...</a><br /></td></tr>
<tr class="separator:gaccf292c6b1c6a47b5ca5c77f7dd21f03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92937f99000195031d20e30f88a6eb13"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__context.html#ga92937f99000195031d20e30f88a6eb13">lsdn_context_set_overwrite</a> (struct <a class="el" href="structlsdn__context.html">lsdn_context</a> *ctx, bool overwrite)</td></tr>
<tr class="memdesc:ga92937f99000195031d20e30f88a6eb13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ignore if any of the interfaces or rules LSDN would create already exists.  <a href="#ga92937f99000195031d20e30f88a6eb13">More...</a><br /></td></tr>
<tr class="separator:ga92937f99000195031d20e30f88a6eb13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54e83eca670fbf0f8d319d0a59b7559e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__context.html#ga54e83eca670fbf0f8d319d0a59b7559e">lsdn_context_get_overwrite</a> (struct <a class="el" href="structlsdn__context.html">lsdn_context</a> *ctx)</td></tr>
<tr class="memdesc:ga54e83eca670fbf0f8d319d0a59b7559e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query if LSDN should overwrite any of the interfaces or rules.  <a href="#ga54e83eca670fbf0f8d319d0a59b7559e">More...</a><br /></td></tr>
<tr class="separator:ga54e83eca670fbf0f8d319d0a59b7559e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf625919c8b38055b7180e503858194cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="include_2errors_8h.html#ad709ac5a2480416ac39c05cc1b2fdcd8">lsdn_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__context.html#gaf625919c8b38055b7180e503858194cd">lsdn_validate</a> (struct <a class="el" href="structlsdn__context.html">lsdn_context</a> *ctx, <a class="el" href="include_2errors_8h.html#afd569abca2f30df45351f01302e98a37">lsdn_problem_cb</a> cb, void *user)</td></tr>
<tr class="memdesc:gaf625919c8b38055b7180e503858194cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate network model.  <a href="#gaf625919c8b38055b7180e503858194cd">More...</a><br /></td></tr>
<tr class="separator:gaf625919c8b38055b7180e503858194cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaffb828719218fab3cf258e6c447ff906"><td class="memItemLeft" align="right" valign="top"><a class="el" href="include_2errors_8h.html#ad709ac5a2480416ac39c05cc1b2fdcd8">lsdn_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__context.html#gaffb828719218fab3cf258e6c447ff906">lsdn_commit</a> (struct <a class="el" href="structlsdn__context.html">lsdn_context</a> *ctx, <a class="el" href="include_2errors_8h.html#afd569abca2f30df45351f01302e98a37">lsdn_problem_cb</a> cb, void *user)</td></tr>
<tr class="memdesc:gaffb828719218fab3cf258e6c447ff906"><td class="mdescLeft">&#160;</td><td class="mdescRight">Commit network model to kernel tables.  <a href="#gaffb828719218fab3cf258e6c447ff906">More...</a><br /></td></tr>
<tr class="separator:gaffb828719218fab3cf258e6c447ff906"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Context, commits and high level network model management. </p>
<p>LSDN context is a core object that manages the network model. It allows the app to keep track of constraints (such as unique names, no two virts using the same interface, etc.), validate the model and commit it to kernel tables.</p>
<p>Context also keeps track of all the child objects (settings, networks, virts, physes, names, etc.) and automatically frees them when it is deleted through <a class="el" href="group__context.html#ga5de5df0dc62be87ac5fcfb7479243e29" title="Free a LSDN context. ">lsdn_context_free</a> or <a class="el" href="group__context.html#gaccf292c6b1c6a47b5ca5c77f7dd21f03" title="Clear a LSDN context. ">lsdn_context_cleanup</a>.</p>
<p>In practically every conceivable case, a single app should only have one context; in fact, only one context should exist per physical host. The library allows you to have multiple contexts at the same time (which is equivalent to having multiple instances of an app), but in such case, the user is responsible for conflicting rules on interfaces. In other words: don't do this, things will probably crash and burn if you do. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaffb828719218fab3cf258e6c447ff906"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaffb828719218fab3cf258e6c447ff906">&#9670;&nbsp;</a></span>lsdn_commit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="include_2errors_8h.html#ad709ac5a2480416ac39c05cc1b2fdcd8">lsdn_err_t</a> lsdn_commit </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlsdn__context.html">lsdn_context</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="include_2errors_8h.html#afd569abca2f30df45351f01302e98a37">lsdn_problem_cb</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Commit network model to kernel tables. </p>
<p>Calculates tc rules based on the current network model, and its difference from the previously committed network model, and applies the changes. After returning successfully, the current network model is in effect.</p>
<p>Performs a model validation (equivalent to calling <a class="el" href="group__context.html#gaf625919c8b38055b7180e503858194cd" title="Validate network model. ">lsdn_validate</a>) and returns an error if it fails. Afterwards, works through the memory model in two phases:</p><ul>
<li>In <em>decommit</em> phase, rules belonging to modified (or deleted) objects are removed from kernel tables. Deleted objects are also freed from memory.</li>
<li>In <em>recommit</em> phase, new rules are installed that correspond to new objects &ndash; or new properties of objects that were removed in the previous phase.</li>
</ul>
<p>If an error occurs in the recommit phase, a limited rollback is performed and the kernel rules remain in mixed state. Some objects may have been successfully committed, others might still be in the old state because the commit failed. In such case, <a class="el" href="include_2errors_8h.html#ad709ac5a2480416ac39c05cc1b2fdcd8a2c63c882a67ef896d57b09d4d9e01c5c" title="Network model commit failed and a mix of old, new and dysfunctional objects are in effect...">LSDNE_COMMIT</a> is returned and the user can retry the commit, to install the remaining objects.</p>
<p>If an error occurs in the decommit phase, however, there is no safe way to recover. Given that kernel rules are not installed atomically and there are usually several rules tied to an object, LSDN can't know what is the installed state after rule removal fails. In this case, <a class="el" href="include_2errors_8h.html#ad709ac5a2480416ac39c05cc1b2fdcd8a4f25c670e8543daaa00fcc454d15b9c4" title="Cleanup operation has failed and this left an object in state inconsistent with the model...">LSDNE_INCONSISTENT</a> is returned and the model is considered to be in an inconsistent state. The only way to proceed is to tear down the whole model and reconstruct it from scratch.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>LSDN context. </td></tr>
    <tr><td class="paramname">cb</td><td>Problem callback. </td></tr>
    <tr><td class="paramname">user</td><td>User data for the problem callback.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">LSDNE_OK</td><td>Commit was successful. New network model is now active in kernel. </td></tr>
    <tr><td class="paramname">LSDNE_VALIDATE</td><td>Model validation found problems. Old network model remains active in kernel. </td></tr>
    <tr><td class="paramname">LSDNE_COMMIT</td><td>Errors were encountered during commit. Kernel is in mixed state, it is possible to retry. </td></tr>
    <tr><td class="paramname">LSDNE_INCONSISTENT</td><td>Errors were encountered when decommitting rules. Model state is inconsistent with kernel state. You have to start over. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="lsdn_8c_source.html#l01574">1574</a> of file <a class="el" href="lsdn_8c_source.html">lsdn.c</a>.</p>

</div>
</div>
<a id="gaa09dd71d3d8e6f6366c6107a6f24b67a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa09dd71d3d8e6f6366c6107a6f24b67a">&#9670;&nbsp;</a></span>lsdn_context_abort_on_nomem()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lsdn_context_abort_on_nomem </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlsdn__context.html">lsdn_context</a> *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure the context to abort on out-of-memory. </p>
<p>This sets the out-of-memory callback to a predefined function that prints an error to <code>stderr</code> and aborts the program.</p>
<p>It is recommended to use this, unless you have a specific way to handle out-of-memory conditions. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="lsdn_8c.html#a4934d0757ff77c88c751fb3e1f7c8643" title="Abort on out-of-memory problem. ">lsdn_abort_cb</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>LSDN context. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="lsdn_8c_source.html#l00191">191</a> of file <a class="el" href="lsdn_8c_source.html">lsdn.c</a>.</p>

</div>
</div>
<a id="gaccf292c6b1c6a47b5ca5c77f7dd21f03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaccf292c6b1c6a47b5ca5c77f7dd21f03">&#9670;&nbsp;</a></span>lsdn_context_cleanup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lsdn_context_cleanup </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlsdn__context.html">lsdn_context</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="include_2errors_8h.html#afd569abca2f30df45351f01302e98a37">lsdn_problem_cb</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear a LSDN context. </p>
<p>Deletes the context and all its child objects from memory. Also deletes configured TC rules from kernel tables.</p>
<p>Use this to deinitialize the LSDN context and tear down the virtual network. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>Context to cleanup. </td></tr>
    <tr><td class="paramname">cb</td><td>Problem callback for encountered errors. </td></tr>
    <tr><td class="paramname">user</td><td>User data for the problem callback. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="lsdn_8c_source.html#l00143">143</a> of file <a class="el" href="lsdn_8c_source.html">lsdn.c</a>.</p>

</div>
</div>
<a id="ga5de5df0dc62be87ac5fcfb7479243e29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5de5df0dc62be87ac5fcfb7479243e29">&#9670;&nbsp;</a></span>lsdn_context_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lsdn_context_free </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlsdn__context.html">lsdn_context</a> *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free a LSDN context. </p>
<p>Deletes the context and all its child objects from memory. Does <b>not</b> delete TC rules from kernel tables.</p>
<p>Use this before exiting your program. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>Context to free. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="lsdn_8c_source.html#l00129">129</a> of file <a class="el" href="lsdn_8c_source.html">lsdn.c</a>.</p>

</div>
</div>
<a id="ga54e83eca670fbf0f8d319d0a59b7559e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga54e83eca670fbf0f8d319d0a59b7559e">&#9670;&nbsp;</a></span>lsdn_context_get_overwrite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool lsdn_context_get_overwrite </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlsdn__context.html">lsdn_context</a> *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query if LSDN should overwrite any of the interfaces or rules. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__context.html#ga92937f99000195031d20e30f88a6eb13" title="Ignore if any of the interfaces or rules LSDN would create already exists. ">lsdn_context_set_overwrite</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="lsdn_8c_source.html#l00095">95</a> of file <a class="el" href="lsdn_8c_source.html">lsdn.c</a>.</p>

</div>
</div>
<a id="ga7774773562a2fb2d2954f89a0b4cde8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7774773562a2fb2d2954f89a0b4cde8d">&#9670;&nbsp;</a></span>lsdn_context_new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structlsdn__context.html">lsdn_context</a>* lsdn_context_new </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create new LSDN context. </p>
<p>Initialize a <a class="el" href="structlsdn__context.html" title="LSDN Context. ">lsdn_context</a> struct and set its name to <code>name</code>. The returned struct must be freed by <a class="el" href="group__context.html#ga5de5df0dc62be87ac5fcfb7479243e29" title="Free a LSDN context. ">lsdn_context_free</a> or <a class="el" href="group__context.html#gaccf292c6b1c6a47b5ca5c77f7dd21f03" title="Clear a LSDN context. ">lsdn_context_cleanup</a> after use. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Context name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>NULL</code> if allocation failed, pointer to new <a class="el" href="structlsdn__context.html" title="LSDN Context. ">lsdn_context</a> otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="lsdn_8c_source.html#l00059">59</a> of file <a class="el" href="lsdn_8c_source.html">lsdn.c</a>.</p>

</div>
</div>
<a id="ga6705027791e7b1fe533523e4458020ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6705027791e7b1fe533523e4458020ee">&#9670;&nbsp;</a></span>lsdn_context_set_nomem_callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lsdn_context_set_nomem_callback </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlsdn__context.html">lsdn_context</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__context.html#ga1b298b230140959c9d9a0e2d8c699e03">lsdn_nomem_cb</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure out-of-memory callback. </p>
<p>By default, LSDN will return an error code to indicate that an allocation failed. This function allows you to set a callback that gets called to handle this condition instead. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>LSDN context. </td></tr>
    <tr><td class="paramname">cb</td><td>Callback function. </td></tr>
    <tr><td class="paramname">user</td><td>User data for the callback function. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="lsdn_8c_source.html#l00164">164</a> of file <a class="el" href="lsdn_8c_source.html">lsdn.c</a>.</p>

</div>
</div>
<a id="ga92937f99000195031d20e30f88a6eb13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga92937f99000195031d20e30f88a6eb13">&#9670;&nbsp;</a></span>lsdn_context_set_overwrite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lsdn_context_set_overwrite </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlsdn__context.html">lsdn_context</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>overwrite</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ignore if any of the interfaces or rules LSDN would create already exists. </p>
<p>This flags is active by default. It ensures that LSDN will ignore rules created by previous crashed instances. </p>

<p class="definition">Definition at line <a class="el" href="lsdn_8c_source.html#l00088">88</a> of file <a class="el" href="lsdn_8c_source.html">lsdn.c</a>.</p>

</div>
</div>
<a id="gaf625919c8b38055b7180e503858194cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf625919c8b38055b7180e503858194cd">&#9670;&nbsp;</a></span>lsdn_validate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="include_2errors_8h.html#ad709ac5a2480416ac39c05cc1b2fdcd8">lsdn_err_t</a> lsdn_validate </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlsdn__context.html">lsdn_context</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="include_2errors_8h.html#afd569abca2f30df45351f01302e98a37">lsdn_problem_cb</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Validate network model. </p>
<p>Walks the currently configured in-memory network model and checks for problems. If problems are found, an error code is returned. Problem callback is also invoked for every problem encountered.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>LSDN context. </td></tr>
    <tr><td class="paramname">cb</td><td>Problem callback. </td></tr>
    <tr><td class="paramname">user</td><td>User data for the problem callback. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="include_2errors_8h.html#ad709ac5a2480416ac39c05cc1b2fdcd8a28da4c364ab7260c67758c429f8f46c3" title="No error. ">LSDNE_OK</a></td><td>No problems detected. </td></tr>
    <tr><td class="paramname"><a class="el" href="include_2errors_8h.html#ad709ac5a2480416ac39c05cc1b2fdcd8a4a25833b8749d010587fef6252440263" title="Network model validation failed, and the old model is in effect. ">LSDNE_VALIDATE</a></td><td>Some problems detected. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="lsdn_8c_source.html#l01183">1183</a> of file <a class="el" href="lsdn_8c_source.html">lsdn.c</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
